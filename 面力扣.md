# [1. 两数之和](https://leetcode.cn/problems/two-sum/)

看map里有没有target-num[i],后存入set（num[i],i）

# [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

对strs进行foreach（s）,s转数组排序后key，list设置为map是否有key，list.push(s),mapset(key,list)

排序，相同的压入同一个数组

# [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)on

存入set，只处理没有n-1的，有n+1 len++

# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)原地

nums[i] == 0，splice(i, 1)，push(0)，i--，len--

# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

求面积，移动左右指针中小的

# [15. 三数之和](https://leetcode.cn/problems/3sum/)

三指针，i,j=i+1,k=n-1，优化，跳过重复

# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

while l<r，记录左右两边此时最高。ans+=lmax-h[l]//取小的l或r并移动

# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

滑动窗口l=0，r=-1，while，用set判断当前是否包含重复

# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

统计s和p的次数，滑动窗口，对s头出尾进对比次数

# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

前缀和pre a-pre b=k说明有连续子数组。map记录pre的次数，看map[presum - k]的次数，

# [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

按左端点排序
    let cur = intervals[i]
    if (pre[1] >= cur[0]) {//前的右超过现在左，有重合
      pre[1] = Math.max(pre[1], cur[1])//右端取大的
    } else {
      res.push(pre)//不重合时压入
      pre = cur

# [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

 取模 三次翻转 先反一次 取左右分别反一次 拼起来 [...n1, ...n2]

或者nums.splice(0, 0, ...nums.splice(n - k))

# [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

while的边界l<r t<b从左上开始顺时针压入 lrtb变化 t==b剩一行左到右 l==r剩一列上到下

# [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

主对角对称 再左右对称

# [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

//这种题都从右上角开始
 if (matrix[i] [j] < target)
      i++// 这一行剩余元素全部小于 target，排除
    else j-- // 这一列剩余元素全部大于 target，排除

# [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

快慢一起走 相遇时头和慢走 相遇再入口

# [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

首位都为0，考虑进位位。l1为null，交换，保证l1更长。求进位，拼在l1，递归处理

# [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

一个节点先走n

# [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

if(!head||!head.next) return head

let node=head.next

  head.next=swapPairs(node.next)

  node.next=head//node变头

  return node

# [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

用map存所有node信息

第一次遍历，生成一个具有val属性的链表；map.set(cur, new Node(cur.val))；cur = cur.next

第二次遍历，根据map映射关系，将random和next指针指向对应的节点或者null;map.get(cur).next = map.get(cur.next) || null

​    map.get(cur).random = map.get(cur.random) || null

​    cur = cur.next

return map.get(head)

# [148. 排序链表](https://leetcode.cn/problems/sort-list/)

存入数组排序，最后arr[i].next = arr[i + 1];

# [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

暴力 转数组交换

cur推进。走了k步，递归调用。while (count > 0) {// k次循环

​      let next = head.next// head指针推进 

​      head.next = cur// 让head节点的next指向cur

​      cur = head

​      head = next// head推进一步，cur尾随它

​      count--

​    }

​    head = cur// 让head指针重新指向新链的头结点

# [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

优先队列priorityqueue，小根堆。哨兵dummy，小根堆dequeue加入结果链表，补充堆

# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

let tem=root.left

​    root.left=invertTree(root.right)

​    root.right=invertTree(tem)

# [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

let l = dep(node.left), r = dep(node.right)

​    ans = Math.max(ans, l + r + 1)//求过该点的最大直径

​    return Math.max(l, r) + 1//该节点的深度

return ans - 1

# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

中序遍历 有序

# [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

数组中间为根，左边或右边还有递归创建

# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

前序ps, pe, 中序is, ie。根为ps，mid为求得的中序中的ps位置，lnum = mid - is//左子树节点数。 root.left = build(ps + 1, ps + lnum, is, mid - 1)，    root.right = build(ps + lnum + 1, pe, mid + 1, ie)

# [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

前序入数组，left=null，.right = arr[i]

# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

层序，每层结束（length-1）压入

# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

l,r递归，if (l && r) return root//左右都找到，返回当前

  if (!r) return l

  if (!l) return r

# [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

const left = dfs(root.left), right = dfs(root.right)// 左右子树提供的最大路径和

​    const innerMax = left + right + root.val// 当前子树内部的最大路径和

​    max = Math.max(max, innerMax)// 挑战最大纪录

​    const output = root.val + Math.max(0, left, right)// 当前子树对外提供的最大和

​    return output < 0 ? 0 : output// 如果对外提供的路径和为负，直接返回0。否则正常返回

return max

# [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

遇到1后，dfs把相邻的变为0继续dfs

# [207. 课程表](https://leetcode.cn/problems/course-schedule/)

for inDgree[prerequisites【i】[0]]++// 求课的初始入度值

​    if (map[prerequisites【i】[1]]) // 当前课已经存在于邻接表

​      map[prerequisites【i】[1]].push(prerequisites【i】[0])// 添加依赖它的后续

​    else map[prerequisites【i】[1]] = [prerequisites【i】[0]]

初始queue压入入度为0的

let sel = queue.shift()// 当前选的课，出列

​    count++ // 选课数+1

​    const toenqueue = map[sel]// 获取这门课对应的后续课

​    if (toenqueue && toenqueue.length) {  // 确实有后续课

​      for (let i = 0; i < toenqueue.length; ++i) {

​        inDgree[toenqueue[i]]-- // 依赖它的后续课的入度-1

​        if (inDgree[toenqueue[i]] === 0)// 如果因此减为0，入列

​          queue.push(toenqueue[i])

​      }

​    }

# [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

记录新鲜数目，坏的压入queue。感染四周的，记录数目并继续。最后比较数目

# [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)



# [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

if (targetSum === node.val) path++

​    targetSum -= node.val//选

​    count(node.left, targetSum)

​    count(node.right, targetSum)

​    targetSum += node.val//撤销

# [46. 全排列](https://leetcode.cn/problems/permutations/)

定义dfs（path），used={}，path的长==nums的，复制压入res。遍历nums，if used了continue，path.push，设置used true，dfs，pop弹出，设置used false。调用dfs（[]）

# [78. 子集](https://leetcode.cn/problems/subsets/)

path.push(nums[index])// 选择这个数

​    dfs(index + 1, path)// 基于该选择，继续往下递归，考察下一个数

​    path.pop() // 上面的递归结束，撤销该选择

​    dfs(index + 1, path)// 不选这个数，继续往下递归，考察下一个数

# [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

const s = letterMap[Number(digits[i])]// 当前数字对应的字母

​    for (let c of s) // 一个字母是一个选择，对应一个递归分支

​      dfs(path + c, i + 1)// 选择翻译成letter，生成新字符串，i指针右移继续翻译（递归）

# [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

if (sum === target)

​        res.push(tem.slice

tem.push(candidates[i])// 选这个数

​      dfs(i, tem, sum + candidates[i]) // 基于此继续选择，传i，下一次就不会选到i左边的数

​      tem.pop()

# [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

let set = new Set(['()'])

  for (let i = 2; i <= n; ++i) {

​    let nextset = new Set()

​    for (let s of set) {//在n-1的组合中加一队（），去重

​      for (let j = 0; j <= s.length; ++j)

​        nextset.add(s.slice(0, j) + '()' + s.slice(j))

​    }

# [79. 单词搜索](https://leetcode.cn/problems/word-search/)

标记已经访问，上下左右find||，if (board[i][j] === word[0] && find(i, j, 0))// 找到起点且递归结果为真，找到目标路径

# [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

if (i == j) {

​        dp[i】[j] = true;

​      } else if (j - i == 1 && s[i] == s[j]) {//两个字符组成

​        dp[i】[j] = true;

​      } else if (j - i > 1 && s[i] == s[j] && dp[i + 1】[j - 1]) {

​        dp[i】[j] = true;

​      } else {

​        dp[i】[j] = false;

​      }

if (dp[start】[i]) {

​        tem.push(s.slice(start, i + 1))

​        dfs(tem, i + 1)

​        tem.pop()

​      }

# [51. N 皇后](https://leetcode.cn/problems/n-queens/)

 如果当前点的所在的列，所在的对角线都没有皇后，即可选择，否则，跳过，！cols.has

board[row】[col] = 'Q'// 放置皇后

​        cols.add(col)// 记录放了皇后的列

​        dia1.add(row + col)// 记录放了皇后的负对角线

​        dia2.add(row - col)// 记录放了皇后的正对角线

​        helper(row + 1)// 继续选择，往下递归

​        board[row】[col] = '.'// 撤销该点的皇后

​        cols.delete(col)  // 对应的记录也删一下

​        dia1.delete(row + col)

​        dia2.delete(row - col)

# [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

一次while   

s = mid

​      r = mid - 1//找左边界,关键向左走

二次while

e = mid

​      l = mid + 1//找右边界,关键向右走

# [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

比较nums[0] <= nums[mid]，再判断target在0-mid间，或mid-len-1间

# [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

if (nums[mid] < nums[r])

​      r = mid

​    else l = mid + 1

  }

  return nums[l]

# [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

# [155. 最小栈](https://leetcode.cn/problems/min-stack/)

# [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

# [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

# [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

while (sta.length && temperatures[i] > temperatures[sta[sta.length - 1]]) {//找第一个比栈中大

​      const j = sta.pop()

​      res[j] = i - j

​    }

​    sta.push(i)