



Vue的响应式原理是Vue框架的核心特性之一，它确保了当数据模型发生变化时，视图会自动更新。这一机制主要依赖于JavaScript中的Object.defineProperty方法来实现。

以下是Vue响应式原理的详细解释：

### 1. 数据劫持（Data Hijacking）

当Vue实例被创建时，它的data对象中的所有属性都会被遍历。Vue通过Object.defineProperty对这些属性进行劫持（或称数据绑定），为每个属性创建一个getter和setter。

- **getter**：当读取数据时，getter会被触发，它会记录这个数据的依赖关系，即谁在读取这个数据。
- **setter**：当修改数据时，setter会被触发，它会通知所有依赖这个数据的变化的视图或组件，告诉它们数据已经发生了变化。

### 2. 依赖收集（Dependency Collection）

在组件渲染过程中，如果某个数据被读取，Vue会记录这个数据与当前组件的依赖关系。这一过程称为依赖收集。Vue通过一种叫做“依赖收集”的机制，将数据和视图建立起联系。

### 3. 发布-订阅模式（Publisher-Subscriber Pattern）

Vue的响应式系统采用了发布-订阅模式。每个组件实例都有一个watcher实例，它会在组件渲染的过程中被创建。当数据变动时，setter会通知所有订阅了该数据的watcher实例，然后这些watcher会调用它们的回调函数，促使视图更新。

### 4. 依赖通知与视图更新

当依赖的数据发生变化时，setter会通知之前收集到的所有依赖（即watcher），告诉它们数据已经改变。这些watcher会触发它们的回调函数，导致相关的视图重新渲染。

### 5. 异步更新队列

Vue的响应式系统实际上使用了异步更新队列，以提高性能。当数据变化时，Vue不会立即更新DOM，而是开启一个队列，并缓冲在同一个事件循环中发生的所有数据改变。如果同一个watcher被多次触发，只会被推入到队列中一次。这种去重和缓冲的机制意味着只有真正需要更新的视图才会被重新渲染，减少不必要的DOM操作。

通过这种方式，Vue的响应式系统确保了数据和视图之间的同步，并且提高了性能和效率。这种设计使得状态管理变得更加简单和直观，同时，由于不需要手动操作DOM，也大大提升了代码的可维护性和可读性。



# 事件循环

宏任务是由宿主环境（如浏览器或 Node.js）提供的任务，那些需要较长时间才能完成的任务，通常涉及I/O操作，

1. setTimeout 和 setInterval

2. **I/O 操作：**包括文件读写、网络请求等异步操作。

3. 事件回调


微任务是在当前任务执行结束后立即执行的任务，它可以在当前任务之后、下一个宏任务之前执行。在同一轮事件循环中的宏任务结束后立即执行。在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务

在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行

1. Promise 回调：
2. **MutationObserver：**监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务
3. process.nextTick

```js
new Promise(function(resolve) {
    console.log('promise1');//promise立即执行的
    resolve();//加入微任务
    
async function async1() {
    console.log('async1 start');
    await async2();//async2执行完后让出线程
    console.log('async1 end');//加入微任务
}
async function async2() {
    console.log('async2');
}
```



# diff hand

**sameVnode**

判断两个节点是否相同，并不是完全一毛一样，而是关键属性一样

```js
function sameVnode(a, b) {    
    return (
        //key 属性, tag 属性是否相等, 是否是input 节点
        //!! 是一个逻辑运算符，用于将值转换为布尔类型。data 属性是否都存在或都不存在,data可以不同
        a.key === b.key &&
        a.tag === b.tag &&
        !!a.data === !!b.data &&
        sameInputType(a, b)
    )
}
```

比较规则

不会对两个数组进行改变（比如不会插入，不会删除其子项）而所有比较过程中都是直接 插入删除 真实页面DOM

1新前与旧前相同，新后与旧后相同都是更新即可

是sameVnode就patchVnode（继续处理这两个相同节点的子节点，或者更新文本），index更新

2新后与旧前相同，旧前移动到旧中所有未处理节点的最后面

```js
parentElm.insertBefore(oldStartVnode.elm,oldEndVnode.elm.nextSibling);
```

4新前与旧后相同，旧后移动到旧中所有未处理节点的最前面

```js
parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
```

5都不同

生成旧子节点数组以 vnode.key 为key 的 map 表

拿新前判断它的key是否在上面的map 中 

```
oldKeyToIdx[newStartVnode.key]
```

不存在，则新建DOM。

```
createElm(newStartVnode, parentElm, oldStartVnode.elm)
```

存在，继续判断是否 sameVnode

```
parentElm.insertBefore(vnodeToMove.elm, oldStartVnode.elm);
```

开始位置大于等于结束位置，说明所以节点都遍历过了，则结束循环，新的还有添加，旧的还有删除

```js
parentNode.removeChild(el);
    或者
    createElm(newCh[newStartIdx], parentElm, refElm//refElm 获取的是 newEndIdx 后一位的节点
    );
```

**vue3在diff算法中相比vue2增加了静态标记**, 其作用是为了**会发生变化的地方添加一个flag标记**，下次发生变化的时候直接找该地方进行比较,提高性能

# vue3的优化

Tree shaking 编译阶段利用ES6 Module判断哪些模块已经加载。判断那些模块和变量未被使用或者引用，进而删除对应代码

**Vue3中对不参与更新的元素，会做静态提升**，只会被提前创建一次，在渲染时直接复用。这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用

vue2的Object.defineProperty： 检测不到对象属性的添加和删除，数组API方法无法监听到，需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

Proxy 并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归

# axios

请求拦截：[axios请求](https://so.csdn.net/so/search?q=axios请求&spm=1001.2101.3001.7020)拦截会先执行最后指定的回调函数，依次向前面执行，先进后出

响应拦截：axios响应拦截会先执行最先指定的回调函数，依次向后面执行，先进先出

# vite

webpack:打包：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用,要很长时间才能启动开发服务器，即使使用模块热替换（HMR），热更新速度也会随着应用规模的增长而显著下降，文件修改后的效果也需要几秒钟才能在浏览器中反映出来

HMR：允许一个模块 “热替换” 它自己，而不会影响页面其余部分

1**依赖** 大多为在开发时不会变动的纯 JavaScript，(组件库)。Vite 将会使用 esbuild 预构建依赖,比以 JavaScript 编写的打包器预构建依赖快 10-100 倍.

Esbuild 使用 Go 语言编写,JavaScript 是一门解释型语言，而 Go 是一种编译型语言。Go 具有多线程运行能力，而 JavaScript 是一门单线程语言。

2**源码** 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。

Vite 以 [原生 ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码

**快速冷启动**：只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理（利用的是浏览器对esMoudle的原生支持），所以节省了webpack 那一套打包转化封装的逻辑。

**按需编译、模块热更新：**采用立即编译当前修改文件的办法。同时 vite 还会使用缓存机制( http 缓存 => vite 内置缓存 )**是基于缓存的热更新**。

文件缓存：Vite 会将预构建的依赖缓存到`node_modules/.vite`。它根据几个源来决定是否需要重新运行预构建步骤:`package.json` 中的 `dependencies` 列表， package-lock等

浏览器缓存：源码模块的请求会根据 `304 Not Modified` 进行协商缓存，依赖模块请求会以 HTTP 头 `max-age=31536000,immutable` 强缓存，以提高在开发时的页面重载性能。一旦被缓存，这些请求将永远不会再到达开发服务器

**生产环境仍用Rollup打包**： 由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）

不用 ESBuild 打包，Vite 目前的插件 API 与使用 `esbuild` 作为打包器并不兼容





&& 运算，如果前面值为true,则结果为后面的值。如果前面值为false,则值为前值. 

|| 运算，如果前面值为true,则结果为前面的值,如果前面的值为false,则结果为后面的值。



proxy实现的过程是在目标对象之前设置了一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写



