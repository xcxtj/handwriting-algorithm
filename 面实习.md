# 打包

tsc和rollup
tsc将ts转为js文件
后台node服务器监听
rollup打包（vite生产环境使用），找出vc和view。vc生成bundle，作为view的入口

类似webpack打包

# 瀑布流 虚拟列表

多列等宽不等高，动态加载无限滚动，插入到高度最小列

频繁dom计算 短暂白屏，多预加载几条

虚拟列表滚动
监听滚动，当前位置。判断哪些渲染。只渲染这些，加点缓冲，位置。滚动时重算
滚动容器 overflowy auto
translatey offset
vfor in data.slice(start,end) 
start=scrolltop/itemheight-buff
end=start+len+buff缓存，多放几个
offset=start*height
滚动里面求start

# pnpm

软连接 避免重复下载

npm都会下载

# Picasso

### **核心原理与架构设计**

1. **JS驱动原生渲染**
   Picasso通过下发携带界面逻辑的JS代码，由SDK解释执行并驱动原生渲染，实现跨平台一致性。视图树通过`PModel`中间结构，转换为原生组件，确保原生体验与高性能。
2. **无状态视图与单向数据流**
   摒弃传统MVC的视图对象概念，**View被视为纯函数**，接收不可变的静态类型`Model`业务数据，生成无状态视图。用户事件处理作为`Model`的变换函数，通过修改状态触发视图更新（`needLayout()`），形成“Model→View→事件→Model”的单向数据流，彻底隔离视图与业务状态，逻辑更清晰。
3. **声明式布局与预计算**
   布局采用**DSL表达即计算**机制，在构建时完成布局计算，避免运行时重复开销。结合数据预处理（如颜色转换、富文本解析），进一步减少渲染耗时。

### **动态化能力与工程实践**

1. **动态下发与灰度发布**
   业务逻辑以JS包形式动态下发，支持灰度发布。内置**三级缓存策略**（内存缓存→内置Asset资源→远程拉取）保障高加载成功率，结合预加载机制降低首屏延迟。
2. **模块化与扩展性**
   - **Pexus模块化架构**：业务以独立模块封装，高内聚低耦合，支持组合为模块树复用逻辑。
   - **插件化机制**：核心功能（如路由、埋点）通过插件扩展，支持定制化框架适配业务需求。
   - **服务通信**：单例`Service`作为模块间通信桥梁，通过事件订阅/发布机制实现解耦。

### **性能优化策略**

1. **服务端渲染（SSR）**
   针对首屏性能瓶颈，支持SSR实现接口聚合，将多接口请求合并为单一数据源，显著降低首屏渲染耗时。
2. **预计算与高效更新**
   布局计算、数据处理在渲染前完成，结合差量更新机制（仅变更触发布局刷新的部分），避免全量渲染带来的性能损耗。
3. **生命周期精细化控制**
   视图控制器（`VC`）管理`onLoad`、`onAppear`等生命周期，精准控制资源加载与释放，优化内存占用。

------

### **开发体验提升**

1. **强类型与不可变性**
   Model强制静态类型与非空约束，通过工具链自动生成TypeScript定义，提升代码健壮性；不可变数据模型避免副作用，简化状态管理。
2. **响应式开发范式**
   基于Flux思想，数据变更自动驱动视图更新，开发者只需关注状态流转，降低手动同步视图的复杂度。
3. **原生能力桥接**
   `VC`作为原生页面载体，无缝集成设备能力（如相机、GPS），同时统一管理原生生命周期与JS逻辑。

Picasso框架通过**无状态视图+单向数据流**解决传统MVC架构的复杂度问题，以**动态化下发+预计算**保障性能，借助**模块化与插件化**提升扩展性，成为兼顾开发效率、跨端一致性与高性能的解决方案。其设计理念适用于对动态更新、首屏速度及代码维护性要求较高的复杂业务场景。

# 拍照识别搜索

进入相机页登录判断

拍照调用api，formdata调桥压缩图片，上传云存储，返回图片url

算法根据图片调用大模型获取文字信息，frame信息，返回

中间页，前端根据frame展示图框，可点击搜索

浮窗页展示商户列表，使用搜索页封装的商户卡片和搜索页一致，按照用户距离优先排序

（拿到ocr数据就在后台发起搜索请求，缓存到本地。点击后就可直接展示，减少延迟。更优化，后端得到ocr时就搜索，所有结果返回给前端）

# 长按搜索

复制，最大长度，爬虫大量复制风险
长按弹框组件，点击搜索。长按某个词，前端检索词性表，根据结果选择最小分词(算法分词，选中分词。点击其他区域取消选中

# Sug页性能优化

请求预加载  首页预加载 优先使用缓存渲染 （hotSuggest缓存等待时间减少Xms） 加载态使用骨架屏 

Picasso页面加载过程 

提高页面加载性能，页面加载速度，提高秒开率 

方法：预下载js（减少包体积），预热js，优化首屏渲染，预加载（将数据提前获取存到客户端，用到 时直接取缓存代替网络请求的方式，减少业务数据获取时间） 

预加载（服务端推送的，客户端主动fetch） 

智能预加载，算法预测用户行为，超过某个概率时 预加载，节约资源流量，降低服务端压力

预加载，进页面读本地接口缓存，有且在有效期，使用，直接渲染。没有，发请求，骨架屏

首屏性能瓶颈在接口过多(串行接口尤其影响秒开)，ssr实现接口聚合，首屏多个依赖接口整合成一个，降低首页渲染耗时

# 页面创建

页面构建 创建，初始化，api加载数据，页面渲染
路由创建目标页面。页面容器初始化，完成首元素渲染。页面发请求获取数据。页面构建视图模型，将视图元素渲染到页面

# 热榜  问题-方案-结果

起始页main module下各种module 输入框 内容区，搜索历史，搜索推荐，各种view

热榜旧样式很多，实验，数据来源复杂，整合为一个。统一设计
约定来源，兼容。不同设备宽度，折叠屏
深色模式
滚动，点击事件，
埋点
真实曝光，统一键盘弹起逻辑，获取显示的位置比对。去重，
接口刷新数据
预加载，取缓存
承载结果页样式



针对移动端搜索起始页的热榜模块进行重构与优化，整合原有分散的实验性热榜样式及复杂数据源（如全国热点、本地热点、垂类榜单等），解决旧版本存在的多端样式不一致、曝光统计失真等问题

起始页架构核心容器，管理输入框、内容区（热榜/搜索历史/推荐）等子模块

新样式开发，一个外边框，几十条热榜数据对应每个item，包含排名，title，icon，热度，保证样式一致性，留存率提升7.1，点击量涨59

热榜接口刷新频率不是很高，视图会更新。定时获取新数据？

搜索列表承接页面，搜索页面会展示热点的排名，解释信息，以及热榜关联的地点，商户，活动信息等。支持运营后台配置

适配不同设备宽度（手机/平板/折叠屏），获取屏幕宽度或者调api判断，展示宽度调整（折叠屏正常逻辑处理，只是多展示一个页面）

深色模式适配 根据系统主题有api，通过颜色映射表实现无缝切换，确保可读性



性能优化，热榜预加载。（首页加载耗时高，秒开率监控，热榜影响比较大，考虑预加载）

提前到首屏异步发请求，不阻塞首页关键进程。有类似storage存储缓存数据，展示判断参数是否匹配直接展示。新的请求不阻塞，更新缓存。退出app时应该清除掉。

有预加载，sug页没有接口聚合

（算法可预测用户行为，超过某个概率时预加载，节约资源流量）



因为旧有逻辑全量曝光，影响ctr置信度，所以

埋点曝光  被遮挡误上报（ctr偏低）（首次展示，用户操作后）获取元素位置，键盘高度，判断是否真实进入可视区域。生成埋点数据，等待处理完后统一上报。同一会话中重复滑入可视区域会有去重，每个item根据特定id，仅上报一次。上报过的不会再上报。ctr置信度提高。沉淀出标准技术方案



统一处理不同设备的键盘弹起行为，统一封装keyboard相关事件，保障弹出，键盘状态检测（meizu vivo等设备白名单，基建或我们发版修复，手动处理）



搜索接口随输入刷新，会有节流限制，(50ms内只能一次请求？)，也就限制了上报频率



背景：整合原有分散的实验性热榜样式及复杂数据源（如全国热点、本地热点、垂类榜单等），样式优化，优化埋点逻辑













